{
  "id": "17959",
  "title": "technical explanation and comparison of USB booters?",
  "isPinned": false,
  "isFirstTopic": false,
  "isLocked": false,
  "tags": [],
  "forumNotes": [
    {
      "id": "165415",
      "timestamp": "2013-01-06T23:13:43+00:00",
      "author": "mikewse",
      "content": "I\u0027m trying to understand better how the different USB booting products and tools (grub4dos, syslinux, unetbootin, etc) work, what phase of the booting they participate in, and how they differ from each other.\n\nI\u0027ve googled for the past two days but I\u0027m finding hundreds and hundreds of tutorials that show what commands to execute, but don\u0027t explain what\u0027s going on behind the scenes. Also, many of these tutorials are from 2006-2009 so I\u0027m uncertain on how relevant they are today.\n\nAre there any nice resources with technical explanations and comparisons of the different boot setups that I missed? I\u0027m more interested in the ways a USB stick can be organized and the products being executed as part of its boot rather than the utilities that configure them.\n\nThanks\n\nMike\n\n"
    },
    {
      "id": "165416",
      "timestamp": "2013-01-06T23:28:55+00:00",
      "author": "steve6375",
      "content": "\u003e Are there any nice resources with technical explanations and comparisons of the different boot setups that I missed? I\u0027m more interested in the ways a USB stick can be organized and the products being executed as part of its boot rather than the utilities that configure them.\n\nCan you explain further why you want this and what you are trying to achieve?\n\ngrub4dos and syslinux are bootloaders/bootmanagers, [unetbootin](http://sourceforge.net/apps/trac/unetbootin/wiki/howitworks \"External link\") is an app that applies syslinux or grub (depending on the OS you ask it to boot).\n\nSome explanation on how BIOSes boot can be found [here](https://sites.google.com/a/rmprepusb.com/www/home/rmprepusb-manual#TOC-Explanation-of-how-BIOSes-boot-from-a-USB-device \"External link\"). The main issue with USB booting is the BIOS bugs that we often run into, rather than any bootloader issues...\n\n"
    },
    {
      "id": "165417",
      "timestamp": "2013-01-06T23:50:42+00:00",
      "author": "mikewse",
      "content": "Primarily, I want to \"understand\" and not just \"do\". I\u0027m overwhelmed by all different tutorials with a few different tweaks here and there and have a hard time judging what makes a difference and what doesn\u0027t.\n\nSecondly, I want to make multi-boot sticks for myself, as modular as possible so I can easily edit them to add/remove features.\n\nI\u0027m sure you pros on this forum have gained this knowledge through long and hard work, but I was hoping for at least some kind of general overview on how the (popular) pieces fit together, that can be learnt much quicker :-)\n\n"
    },
    {
      "id": "165419",
      "timestamp": "2013-01-06T23:54:56+00:00",
      "author": "steve6375",
      "content": "There is a grub4dos tutorial on my site - did you see that?\n\nI am not sure where to go for a good syslinux tutorial...\n\ngrub4dos is under constant development and improvement and seems to me to be more flexible than syslinux (but I am not that experienced with syslinux...)\n\n"
    },
    {
      "id": "165434",
      "timestamp": "2013-01-07T14:11:39+00:00",
      "author": "mikewse",
      "content": "Thanks Steve, I have indeed looked through your site previously but missed the part about BIOSes. I\u0027ll read that and also read the grub4dos article again, and then come back here to clarify what more knowledge I seek :-)\n\nAbout syslinux: is your view that everything possible with syslinux is also doable in grub4dos? (in that case I can skip syslinux and just focus on grub4dos, in addition to the native dos/windows boot systems)\n\n"
    },
    {
      "id": "165435",
      "timestamp": "2013-01-07T14:17:23+00:00",
      "author": "steve6375",
      "content": "As I say, I am not that experienced with syslinux (because I have not yet found anything that syslinux can do that grub4dos cannot!), but from what I have seen in the past few years, grub4dos can do everything and much more (map iso as a partition or to memory, firadisk support, hi-res bmp wallpapers, conditional title entries, batch files, grub4dos executables, re-sizeable menus, direct manipulation of memory, etc. etc. etc....)\n\n"
    },
    {
      "id": "165447",
      "timestamp": "2013-01-07T18:49:26+00:00",
      "author": "ady",
      "content": "@mikewse,  \n\nIt depends on the kind of details you are looking for, and your previous knowledge.  \n\n++For example++ , I potentially \"could\" say something like \"the boot process goes BIOS -\\\u003e MBR -\\\u003e PVR -\\\u003e OS\". In a certain sense / context, that description may sound good enough; and in others, it is not detailed nor accurate enough.  \n\nMaybe the interested \"student / learner / reader\" (in this case, you) don\u0027t even know / understand each acronym. Or maybe a text where each acronym is explained is \"too basic\" and boring already.  \n\nBut surely there are other possible contexts where mentioning \"(U)EFI\" as a different method than \"BIOS\" in some newer hardware might be acceptable. Or we could mention some media example(s) that skips the MBR (there is no need nor use for it in that media), or other newer and bigger media that replaces the old MBR with an alternative GPT method, or...  \n\nSo if you want to get the general concepts and understanding (not YET for configuration or usage of a specific boot loader / boot manager), I would suggest reading [http://en.wikipedia....rn_boot_loaders](http://en.wikipedia.org/wiki/Booting#Modern_boot_loaders \"External link\") and down till the end of that page. If you are interested (and have more time), start at the very beginning of that wiki page. As always in wiki pages, maybe not each and every concept is completely accurate, but it might give you a good first step.  \n\nAt the end of that linked Wikipedia page, there are several \"See Also\" links, including [http://en.wikipedia....of_boot_loaders](http://en.wikipedia.org/wiki/Comparison_of_boot_loaders \"External link\").  \n\nHTH,  \nAdy.   \n"
    },
    {
      "id": "165456",
      "timestamp": "2013-01-07T21:55:30+00:00",
      "author": "mikewse",
      "content": "I\u0027ve been working as sysadm (Unix) and programmer all since the DOS days so I know my way well around the booting process, MBR, VBR, different hard disk formats etc. But I haven\u0027t dived into USB media before so I\u0027m new to its different configuration possibilities, what tricks the boot artefacts (grub4dos boot sector, grub4dos executable, etc) pull off to enable booting from USB, and what operating systems these tricks work, or doesn\u0027t work, for.\n\nTo start out I\u0027m wondering about the different ways a USB stick can be organized (with or without partition table, fixed or removable, etc) and how (if?) this relates to what boot artefacts may be used and how they are added? :smile:\n\n"
    },
    {
      "id": "165468",
      "timestamp": "2013-01-08T07:06:23+00:00",
      "author": "Sha0",
      "content": "\u003e I\u0027ve been working as sysadm (Unix) and programmer all since the DOS days so I know my way well around the booting process, MBR, VBR, different hard disk formats etc. But I haven\u0027t dived into USB media before so I\u0027m new to its different configuration possibilities, what tricks the boot artefacts (grub4dos boot sector, grub4dos executable, etc) pull off to enable booting from USB, and what operating systems these tricks work, or doesn\u0027t work, for.\n\u003e\n\u003e To start out I\u0027m wondering about the different ways a USB stick can be organized (with or without partition table, fixed or removable, etc) and how (if?) this relates to what boot artefacts may be used and how they are added? :smile:\n\nThere are at least two common modes of booting from a USB disk. One is when **BIOS** uses it in a \"hard disk drive\" mode and assigns it **INT 0x13** drive number **0x80** . This mode is typically used with an MBR (including a partition table). Another is when BIOS uses the USB disk in a \"superfloppy\" mode and assigns it INT 0x13 drive number **0x00** . This mode typically does ++not++ have an MBR, but has a single filesystem beginning at the first sector.\n\nDifferent BIOSes have different options. Some BIOSes only support one mode or the other, making it difficult to create a USB disk that works with all BIOSes.\n\nDifferent BIOSes have different ideas for what C/H/S geometries to assign to a USB device, also making it difficult to create a USB disk that works with all BIOSes.\n\nThen there are sometimes other USB options, such as \"external USB floppy disk drive\" and \"external USB optical disc drive\". I don\u0027t think you\u0027re asking about these.\n\nIf you wish to read more about how USB (and other INT 0x13) devices might be presented as bootable devices with BIOS, I\u0027d suggest the **BIOS Boot Specification** , which I\u0027m sure that **Google** will help with.\n\n[Possibly useful post](http://reboot.pro/topic/13676-the-boot-process-a-step-by-step-approach-to-booting/#entry120090 \"\"). (Possibly not.)\n\n"
    },
    {
      "id": "167966",
      "timestamp": "2013-02-15T22:32:59+00:00",
      "author": "trueriver",
      "content": "\u003e ...\n\u003e\n\u003e About syslinux: is your view that everything possible with syslinux is also doable in grub4dos? (in that case I can skip syslinux and just focus on grub4dos, in addition to the native dos/windows boot systems)\n\nSyslinux does some things more neatly than can be done in grub4dos.\n\nFor example the way syslinux drops into a boot prompt to allow you to append items to the kernel command line. In grub4dos this is done by editing the menu, which gives the same result but is not so neat for the general user (but is also more powerful for the expert, who can alter other parts of the menu)\n\nAlso the facility to press F1 for help, F2 for more advanced help, and so on which is common on CD/DVD software. As far as I know (and I might be showing my ingnorance here) such \"hot keys\" don\u0027t exist in grub4dos. If I needed to provide help before the boot in grub4dos I would have a menu item with cat helpfile. So it provides the same function, but it is not so neat for the person writing the menus nor for the user.\n\nIf had to stick to just one, then it would be grub4dos, but given the choice I personally would still sometimes use syslinux.\n\nYou did not ask about grub2, but I will comment anyway. I have yet to see any advantage to grub2 until you get into uefi. It has some, but not all, the nice features of grub4dos, and seems to have a horibbly steep learning curve, which I have never managed to climb.\n\nhope that helps, it is a non-expert impression rather than an expert one.\n\nRiver\\~\\~\n\n"
    },
    {
      "id": "167968",
      "timestamp": "2013-02-15T22:40:42+00:00",
      "author": "steve6375",
      "content": "You can have hotkey support in grub4dos to run a menu item. So you could have a number of \u0027help\u0027 menu entries which could be also invoked by a hotkey. See [here](http://www.rmprepusb.com/tutorials/57---automatic-grub4dos-menu \"External link\") for more details - e.g. auto-number of menu entries, etc.\n\n"
    },
    {
      "id": "167969",
      "timestamp": "2013-02-16T00:00:17+00:00",
      "author": "trueriver",
      "content": "\u003e I\u0027m trying to understand better how the different USB booting products and tools (grub4dos, syslinux, unetbootin, etc) work, what phase of the booting they participate in, and how they differ from each other.\n\nhi Steve,\n\nproducts like unetbootin, yumi are a level higher than grub4dos..\n\nThe higher level products prepare a drive for booting by installing one of the lower level products. Bootloaderinstallers you might call them.\n\nEasy2boot is a kind of mid-way product, as it sits on the boot disk alongside grub4dos (g4d) and re-writes the input for it on the fly - a kind of live front end for a bootloader. You can watch it do its pre-processing before it offers you a menu.\n\nThe products that I would consider to be \"stage2 bootloaders\" all come in the boot sequence between the BIOS and the OS. They include grub4dos, syslinux, lilo, grub legacy, grub2 and no doubt some others.\n\nThis is what happens.\n\nStage 0. Prepare hardware and load stage 1 from the start of some special boot medium.\n\nStage 1. A short program that gives the machine enough intelligence to load stage 2 from some slightly more flexible place on the system.\n\nStage 2. A longer program that is sufficiently flexible to allow choice of OS (either preselected or by operator choice at boot time)\n\nLets look at these in more detail. To give a little bit of comparision, I will also give a taste of how these things were done on another machine, the Interdata 8/16e, which was just becoming obsolete as the early IBM PCs came in. This will help to show what things are this way just because of the original IBM specification which all PCs still follow (until UEFI that is....)\n\n0. The BIOS is contained in ROM (firmware) so that its machine code is always present even when the machine is turned off\n\nThis was not always so. With some effort I can probably remember bootloader for the Interdata 8/16e, because I had to enter it by hand in hex so many times..... Machines even older than that (the original PDPs for example) you had to code in the bootloader in binary on a bank of switches.\n\nNote that BIOS is the name of the IBM PC stage 0 bootloader, the Interdata\u0027s was called \"the 50 sequence\", there is nothing that says a machine has to have a BIOS, it just has to have some kind of stage0 bootloader.\n\nOne of the innovations of BIOS, from which it got its name, was to include stuff that would be useful later: BIOS includes 16bit code that allows for basic input and output even when the OS is running. All OSs from Windows 95 on, and all versions of Linux ever written, ignore this code, so these days it is just taking up space in the firmware in case you suddenly boot into MSDOS 6-22 (or even PCDOS 1.0),\n\nUEFI is another stage0 bootloader. This does not provide the i/o facilities of BIOS, but instead it provides the ability to validate operating systems before they are loaded, and various other stuff. Beyond that I know nothing.\n\nWhen the computer is turned on, some hardware forces the program counter to be the BIOS start address. So as soon as the processor clock is allowed to run, the BIOS starts. It immediately does various housekeeping things (power on self test, etc) and then determines which disk to boot from, depending on user defined settings. It loads the first so-many sectors of the boot disk into memory, and jumps to them. On a floppy this would have been just one sector, on a hard disk it is more. However much code this is, we call that the stage 1 bootloader.\n\nIf you re-flash your motherboard with an alternative to BIOS (UEFI, or perhaps the LinuxBios project) the new code has to be located to start at the same start address - there is no way to alter this within the PC spec.\n\nOn the Interdata you had to do this step by hand, too - enter the program counter on the switch register, press PC, then press run. That meant that, in principle, on that hardware you could write a stage0 that starte4d anywhere you liked. In practice, you always did it the same way as that kept things simple. No doubt that is why IBM chose not to allow the start address to be modified.\n\nOn the interdata you could see stage0 running - would immediately read about 6\" (15cm) of mag tape from the beginning of the reel, and that took about 1.5sec. When the tape stopped, you knew the machine had already jumped into the stage 1 code it had got from the tape.\n\n2. Whatever code was on that first sector gets run. It is 16bit \"real mode\" code that would run on an 8086 chip. A true MBR contains just 446 bytes, at the end of which the machine knows enough to load the stage2 bootloader and jump into it. These can be found on bootable floppies for MSDOS, FreeDOS, and the emergency boot floppies for Windows.\n\nMore commonly these days, the stage 1 lasts longer than 1 sector (I only discovered this fact recently - thanks to Wonko the Sane). But the fact still remains, however long this code is it just has one job, to find and to load the stage2 loader from disk.\n\nLegacy Grub sometimes needed to insert an extra step here - this was the so-called \"stage 1.5\" loader. In that case, the boot sector would load stage 1.5 and stage 1.5 would load stage 2. The extra steps were all taken care of by the grub-install script, and you can find out how they were installed by reading that script on a system that uses legacy grub.\n\nStage 1.5 was necessary when the boot disk was in a format that the stage 1 did not understand. It would be code that did understand the disk format (ext4, say), and the stage 1 would look for the stage 1.5 file on a pre-defined sector of the disk.\n\nFinally at the end of stage 1 (or stage 1.5) we have loaded the stage2 loader and we jump into the newly loaded code.\n\n2. Stage 2 on a linux system has to do three jobs.\n\n2a. load the kernel (and as this is allowed to be supplied compressed, the stage 2 loader needs to be able to gunzip. The loader should attempt to uncompress any filename that ends with z)\n\n2b. optionally load an initial ram disk that the kernel can use before it understands how to access the hardware (some kernels are compiled to be self-sufficient and these do not need a ram disk - for most kernels this step is not optional). Again if the filename ends in z it is gunzipped.\n\n2c. start the kernel with appropriate command line arguments (these are the things like root\u003d/foo pfix\u003d1 and suchlike. They need not be kernel options, they may control other scripts or programs that run at any time the sytem is up. You can see what these are during any live linux with the command. Try adding QQQQ\u003dSteve_is_cool to the kernel options, and get a cheap ego boost later on with\n\n\u003cbr /\u003e\n\n```\ncat /proc/cmdline\n```\n\n\u003cbr /\u003e\n\nBefore it does any of that, it may offer the operator the chance to select which kernel to load, which options to pass to the kernel, and so on - this depends on the configuration you have chosen. This will either be a menu or (with syslinux and friends) you may get the chance to type in the kernel command line before it is booted.\n\nOn the Interdata we had to set a four digit hex number on the switch register - this referred to part of the name of the OS file.\n\nBut what if it is not booting Linux?\n\nThe Windows load process is similar. The stage2 file is called IO.sys (win 9x, Me), NTLDR (NT, 2000, XP) or BOOTMGR (Vista, 7). I do not know if Win8 uses BOOTMGR or something even newer. The process has to start with the loading of the first sector of a disk, but after that the programs diverge.\n\nWhen you boot Windows from a Linux menu, the Linux loader \"chainloads\" into the Windows one. This means that the Linux stage2 loader loads the Windows stage 1 loader and jumps into it. That is why you can press F8 at this point and see the Windows recovery options, for example.\n\nThe reverse process is harder. Microsoft try to make it hard to boot Linux from their bootloaders and do not offer a chainload facility.\n\nOne cunning feature of grub4dos is that it includes a stage2 bootloader called GRLDR which looks sufficiently like NTLDR that the Windows stage 2 loader will allow you to load it (instructions can be found in the Grub4dos documentation). It is no accident that they end with the same three letters.\n\nLOADLIN did the same in the days of win9x.\n\nHope that gives you a bit of useful background\n\nRiver\\~\\~\n\n"
    },
    {
      "id": "167978",
      "timestamp": "2013-02-16T10:14:11+00:00",
      "author": "steve6375",
      "content": "I think you meant \u0027Hi mikewse\u0027 rather than \u0027Hi Steve\u0027!\n\n*I first cut my teeth in computers by keying in machine code using the toggle switches on a DEC PDP8 to run a paper tape reader which reads in the main OS and then another roll of tape which reads in Algol or Fortran. I also designed and built my own microprocessor boards (inc. making the PCBs) from the late 70\u0027s and 80s and over the (many) years have helped design, build and test everything from bespoke Gate Arrays (one of which was used in many ATMs for years) to whole PCs, as well as write BIOSes, functional test programs for ATEs in machine code, etc., etc.!* ![:book:](http://reboot.pro/public/style_emoticons/default/book.gif)\n\n"
    },
    {
      "id": "167983",
      "timestamp": "2013-02-16T12:57:48+00:00",
      "author": "Wonko the Sane",
      "content": "\u003e *I first cut my teeth in computers by keying in machine code using the toggle switches on a DEC PDP8 to run a paper tape reader which reads in the main OS and then another roll of tape which reads in Algol or Fortran. I also designed and built my own microprocessor boards (inc. making the PCBs) from the late 70\u0027s and 80s and over the (many) years have helped design, build and test everything from bespoke Gate Arrays (one of which was used in many ATMs for years) to whole PCs, as well as write BIOSes, functional test programs for ATEs in machine code, etc., etc.!* ![:book:](http://reboot.pro/public/style_emoticons/default/book.gif)\n\nKids today.\n\n[http://www.911cd.net...ic\u003d21702\\\u0026st\u003d122](http://www.911cd.net/forums//index.php?showtopic\u003d21702\u0026st\u003d122 \"External link\")\n\nWhy, in my day....\n\n[http://reboot.pro/in...?showtopic\u003d1908](http://reboot.pro/index.php?showtopic\u003d1908 \"\")\n\n![:cheers:](http://reboot.pro/public/style_emoticons/default/cheers.gif)\n\nWonko\n\n"
    },
    {
      "id": "167988",
      "timestamp": "2013-02-16T15:41:15+00:00",
      "author": "digger",
      "content": "@trueriver - thx very much for your discussion of the RELATIONSHIPS ! please do write more in this, your style of discussion \\~\n\n... and I continue to build my own \"University de Jaclaz\" from countless lectures, link, \\\u0026 examples scattered all over the digital classroom --\n\ngrateful, I am ![:good:](http://reboot.pro/public/style_emoticons/default/good.gif)\n\n\\\u0026 just now becoming familiar w/ Steve\u0027s tools \\\u0026 materials.\n\n... many of us really appreciate a global perspective before a total-immersion \u0027deep-dive\u0027\n\n"
    },
    {
      "id": "167999",
      "timestamp": "2013-02-16T19:01:25+00:00",
      "author": "trueriver",
      "content": "\u003e I think you meant \u0027Hi mikewse\u0027 rather than \u0027Hi Steve\u0027!\n\ncorrect, and it is too late to edit my mistake ![:(](http://reboot.pro/public/style_emoticons/default/sad.png) R\\~\\~   \n"
    },
    {
      "id": "168000",
      "timestamp": "2013-02-16T19:22:10+00:00",
      "author": "trueriver",
      "content": "\u003e Why, in my day....\n\n\u003cbr /\u003e\n\nYes I remember [punched cards](http://www.columbia.edu/acis/history/026-card-700.jpg \"External link\") too, only ours were hand coded and did not have print along the top.\n\nMy first Fortran IV program was coded on them, and our school couldn\u0027t afford an electromechanical card punch. We had a purely mechanical punch (no electronix, just one button for each row) so you had to memorise the punch code before you started. (\u0027A\u0027\u003d10+1, \u0027\\*\u0027 \u003d 10+3+8, etc)\n\nAnd my very first \u0027hack\u0027, age 13, 1968, was to work out for myself the mapping between Hollerith card code and BCD - it was easy, of course as it had to be mapped in hardware (discrete component hardware....)\n\n(BCD was later \\*Extended\\* Binary Coded Decimal Instruction Code, of course, but BCD was a 6 bit code)\n\nTook a lunch time to turn the code into cards. Then wait for teacher to take them to Imperial College and bring the printout back next day. Then correct the mistakes. It is funny that nowadays I get cross if I notice the delay when I click on something... When we did not expect anything to happen till the next day we never minded.\u0027\n\n"
    },
    {
      "id": "168002",
      "timestamp": "2013-02-16T19:32:55+00:00",
      "author": "trueriver",
      "content": "\u003e You can have hotkey support in grub4dos to run a menu item. So you could have a number of \u0027help\u0027 menu entries which could be also invoked by a hotkey. See [here](http://www.rmprepusb.com/tutorials/57---automatic-grub4dos-menu \"External link\") for more details - e.g. auto-number of menu entries, etc.\n\nhi Steve\n\nOK, I am out of date. You couldn\u0027t do that in version 0.4.4 - ie the last entry on the sourceforge page. I only discovered the more recent developments this month and am now playing catch up.\n\n(If someone reading this still has the credentials for the sourceforge page, perhaps a link to more recent development could be made there?)\n\n"
    },
    {
      "id": "168004",
      "timestamp": "2013-02-16T20:04:20+00:00",
      "author": "steve6375",
      "content": "grub4dos at [chenall\u0027s](http://code.google.com/p/grub4dos-chenall/ \"External link\") google code page is well maintained. You can check the grub4dos page (Tut 21) on my site for the latest improvements.\n\n"
    },
    {
      "id": "168005",
      "timestamp": "2013-02-16T20:12:39+00:00",
      "author": "Wonko the Sane",
      "content": "\u003e It is funny that nowadays I get cross if I notice the delay when I click on something... When we did not expect anything to happen till the next day we never minded.\u0027\n\nWell, technology evolves quickly, humans (and their interests :wink:) tend to remain the same :  \n[http://www.googlewithboobs.com/](http://www.googlewithboobs.com/ \"External link\")  \n\ncompare with the classic way ![:whistling:](http://reboot.pro/public/style_emoticons/default/happy22.gif)  \nSpoiler  \n![google-classic-boobs.jpg](http://bunkstrutts.files.wordpress.com/2009/04/google-classic-boobs.jpg)\n\n\u003cbr /\u003e\n\n![:cheers:](http://reboot.pro/public/style_emoticons/default/cheers.gif)\n\nWonko\n\n"
    }
  ]
}