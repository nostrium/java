{
  "id": "14156",
  "title": "Native Boot from a Raw File Image",
  "isPinned": false,
  "isFirstTopic": false,
  "isLocked": false,
  "tags": [],
  "forumNotes": [
    {
      "id": "125505",
      "timestamp": "2011-03-24T11:15:36+00:00",
      "author": "amitr0",
      "content": "All,  \n\nThis is my first post.. Kindly excuse if this is the wrong forum.  \n\n\u003cbr /\u003e\n\nHere is what I want to do:  \n\nI have a file Os.bin which is basically a raw sector dump of a bootable FreeDOS partition. So this os.bin has all sectors from Boot sector till end of partition.  \n\nI want to boot from this file (which lies inside one of my existing disk partitions).  \n\nHere Is what all I have done/tried:  \n\nI have a win2k8r2 MBR dump (512 bytes). Lets call this MBR.BIN. Since os.BIN can reside beyond the 8.4 GB CHS boot boundary, I decied to use an MBR which supported the INT13h LBA reads. Disassembling the win2k8 MBR showed that it supported this feature, hence this choice.  \n\nANyhow, I then went ahead and changed the partition table of MBR.BIN to have only one entry. An active FreeDOS FAT32(0xc) type partition of the exact same specs as my OS.BIN.  \n\nNow I modified the Starting head, sector and cylinder to invalid CHS values FE FF FF so that the boot loader ignores them. Since I was going to do LBA reads, I went ahead and modified the Relative Sector (DWORD) and total Number of Sectors (DWORD) to tha actual LBA of os.bin in the disk (as shown by winhex). So lets say this Os.bin (defragged and contiguous) starts at sector 7903696 and is 31439136 sectors long then my finished partition table looks like...  \n\n80 FE FF FF 0C FE FF FF D0 99 78 00 20 B9 DF 01   \n\n\u003cbr /\u003e\n\nI then cahined MBR.BIN to my XP boot.ini with the entry..  \n\nC:\\\\MBR.BIN\u003d\"FREEDOS\"  \n\n\u003cbr /\u003e\n\nNow I try to boot, but it doesnt work.   \n\nWhere is this simple project going wrong?  \n\nAny suggestions would be useful.  \nThanks  \n\namit   \n"
    },
    {
      "id": "125513",
      "timestamp": "2011-03-24T12:59:36+00:00",
      "author": "Sha0",
      "content": "What is the last message on the screen after you choose the BOOT.INI \"FREEDOS\" entry? Edit MBR.BIN and remove the \"active\" flag for the partition. Try your \"FREEDOS\" choice again and see if MBR.BIN yields an error message. If it does, that at least shows that you are successfully booting MBR.BIN.  \n\nAnd not that it matters, but maybe **.FAT** is a nicer extension than **.BIN** for a FAT FS-formatted partition image? ![:cheers:](http://reboot.pro/public/style_emoticons/default/cheers.gif)   \n"
    },
    {
      "id": "125514",
      "timestamp": "2011-03-24T13:08:42+00:00",
      "author": "abozeeyad",
      "content": "thanks works great.   \n"
    },
    {
      "id": "125517",
      "timestamp": "2011-03-24T13:44:48+00:00",
      "author": "amitr0",
      "content": "@Shao: What is the last message on the screen after you choose the BOOT.INI \"FREEDOS\" entry?   \n\n\\[Amitr0\\] It falls back to the NT error message (which is also surprising and I missed in the original post) \u0027windows could not start because missing Hal.dll...\u0027  \n\n\u003cbr /\u003e\n\n@Shao: Edit MBR.BIN and remove the \"active\" flag for the partition. Try your \"FREEDOS\" choice again and see if MBR.BIN yields an error message. If it does, that at least shows that you are successfully booting MBR.BIN.  \n\n\\[Amitr0\\] Nopes same error message. But it takes a few seconds for the message to pop up.   \n\n1. I am doing this experiment with vmware client 6.5  \n2. The boot sector disassembly, posted below shows it is using BIOS 10h to print, could it be that NTLDR (which already has run before my MBR gets control) changed the graphics mode and hence I am missing the messages?  \n\n\u003cbr /\u003e\n\n@Shao: And not that it matters, but maybe .FAT is a nicer extension than .BIN for a FAT FS-formatted partition image?   \n\n\\[Amitr0\\] Will do! But I need to get this to boot first. Shao, my goal is to create something like yu did, NTLDRDD.SYS and the windows driver to boot an image off a VHD. But I don\u0027t want to copy, I want to learn it by doing it myself. I have windows system programming back ground.  \n\nI have done this so many times before when I wanted to use NTDLR to boot my linux partition. What can be possibly worng? Is it that the original MBR has a different partition table and this ne one doesnt match? That sounds improbable, as this new MBR should erase all existing memory....  \n\nwhat am I missing???  \n\n@abozeeyad : What works great?????  \n\n\u003cbr /\u003e\n\n0:001\\\u003e ur 120a0 120a0+0x1ff  \n000120a0 33c0 xor ax,ax ; clear ax  \n000120a2 8ed0 mov ss,ax ; setup the stack seg  \n000120a4 bc007c mov sp,7C00h ; stack pointer to 7c00h  \n000120a7 8ec0 mov es,ax   \n000120a9 8ed8 mov ds,ax  \n000120ab be007c mov si,7C00h ; move from 7c00  \n000120ae bf0006 mov di,600h ; location to move to  \n000120b1 b90002 mov cx,200h ; size of bytes to move  \n000120b4 fc cld ; clear the destination flags  \n000120b5 f3a4 rep movs byte ptr es:\\[di\\],byte ptr \\[si\\] ; move it!  \n000120b7 50 push ax  \n000120b8 681c06 push 61Ch  \n000120bb cb retf ; jump to new location  \n000120bc fb sti ; reenable interrupts  \n\n000120bd b90400 mov cx,4 ; loop counter to 4  \n000120c0 bdbe07 mov bp,7BEh ; move byte pointer to first partition entry  \n000120c3 807e0000 cmp byte ptr \\[bp+0\\],0 ; is the first byte 0. that is non bootable  \n000120c7 7c0b jl 20D4 ; hmmm less than....so anything from 80h to FFh is less than which ; means it is a boot entry  \n000120c9 0f851001 jne 21DD ; but it is not zero and is greater than so error  \n\n000120cd 83c510 add bp,10h ; next entry  \n000120d0 e2f1 loop 20C3 ; loop back  \n000120d2 cd18 int 18h ; 18h is NO ROM BASIC or simply, press any key to reboot  \n\n\u003cbr /\u003e\n\n000120d4 885600 mov byte ptr \\[bp+0\\],dl ; bp + 0 was 80 for boot flag, now becomes 0  \n000120d7 55 push bp ; save th base pointer to our stack  \n000120d8 c6461105 mov byte ptr \\[bp+11h\\],5 ; set up flags/counters for INT13 extention functions  \n000120dc c6461000 mov byte ptr \\[bp+10h\\],0  \n000120e0 b441 mov ah,41h   \n000120e2 bbaa55 mov bx,55AAh  \n000120e5 cd13 int 13h ; call it   \n000120e7 5d pop bp ; orignal base pointer?  \n000120e8 720f jb 20F9   \n000120ea 81fb55aa cmp bx,0AA55h  \n000120ee 7509 jne 20F9  \n000120f0 f7c10100 test cx,1  \n000120f4 7403 je 20F9  \n000120f6 fe4610 inc byte ptr \\[bp+10h\\]  \n000120f9 6660 pushad  \n000120fb 807e1000 cmp byte ptr \\[bp+10h\\],0  \n000120ff 7426 je 2127  \n00012101 666800000000 push 0  \n00012107 66ff7608 push dword ptr \\[bp+8\\]  \n0001210b 680000 push 0  \n0001210e 68007c push 7C00h  \n00012111 680100 push 1  \n00012114 681000 push 10h  \n00012117 b442 mov ah,42h  \n00012119 8a5600 mov dl,byte ptr \\[bp+0\\]  \n0001211c 8bf4 mov si,sp  \n0001211e cd13 int 13h  \n00012120 9f lahf  \n00012121 83c410 add sp,10h  \n00012124 9e sahf  \n00012125 eb14 jmp 213B  \n00012127 b80102 mov ax,201h  \n0001212a bb007c mov bx,7C00h  \n0001212d 8a5600 mov dl,byte ptr \\[bp+0\\]  \n00012130 8a7601 mov dh,byte ptr \\[bp+1\\]  \n00012133 8a4e02 mov cl,byte ptr \\[bp+2\\]  \n00012136 8a6e03 mov ch,byte ptr \\[bp+3\\]  \n00012139 cd13 int 13h  \n0001213b 6661 popad  \n0001213d 731e jae 215D  \n0001213f fe4e11 dec byte ptr \\[bp+11h\\]  \n00012142 0f850c00 jne 2152  \n00012146 807e0080 cmp byte ptr \\[bp+0\\],80h  \n0001214a 0f848a00 je 21D8  \n0001214e b280 mov dl,80h  \n00012150 eb82 jmp 20D4  \n00012152 55 push bp  \n00012153 32e4 xor ah,ah  \n00012155 8a5600 mov dl,byte ptr \\[bp+0\\]  \n00012158 cd13 int 13h  \n0001215a 5d pop bp  \n0001215b eb9c jmp 20F9  \n0001215d 813efe7d55aa cmp word ptr ds:\\[7DFEh\\],0AA55h  \n00012163 756e jne 21D3  \n00012165 ff7600 push word ptr \\[bp+0\\]  \n00012168 e88a00 call 21F5  \n0001216b 0f851500 jne 2184  \n0001216f b0d1 mov al,0D1h  \n00012171 e664 out 64h,al  \n00012173 e87f00 call 21F5  \n00012176 b0df mov al,0DFh  \n00012178 e660 out 60h,al  \n0001217a e87800 call 21F5  \n0001217d b0ff mov al,0FFh  \n0001217f e664 out 64h,al  \n00012181 e87100 call 21F5  \n00012184 b800bb mov ax,0BB00h  \n00012187 cd1a int 1Ah  \n00012189 6623c0 and eax,eax  \n0001218c 753b jne 21C9  \n0001218e 6681fb54435041 cmp ebx,41504354h  \n00012195 7532 jne 21C9  \n00012197 81f90201 cmp cx,102h  \n0001219b 722c jb 21C9  \n0001219d 666807bb0000 push 0BB07h  \n000121a3 666800020000 push 200h  \n000121a9 666808000000 push 8  \n000121af 6653 push ebx  \n000121b1 6653 push ebx  \n000121b3 6655 push ebp  \n000121b5 666800000000 push 0  \n000121bb 6668007c0000 push 7C00h  \n000121c1 6661 popad  \n000121c3 680000 push 0  \n000121c6 07 pop es  \n000121c7 cd1a int 1Ah  \n000121c9 5a pop dx  \n000121ca 32f6 xor dh,dh  \n000121cc ea007c0000 jmp 0000:7C00  \n000121d1 cd18 int 18h  \n000121d3 a0b707 mov al,byte ptr ds:\\[000007B7h\\]  \n000121d6 eb08 jmp 21E0  \n000121d8 a0b607 mov al,byte ptr ds:\\[000007B6h\\]  \n000121db eb03 jmp 21E0  \n000121dd a0b507 mov al,byte ptr ds:\\[000007B5h\\]  \n000121e0 32e4 xor ah,ah  \n000121e2 050007 add ax,700h  \n000121e5 8bf0 mov si,ax  \n000121e7 ac lods byte ptr \\[si\\]  \n000121e8 3c00 cmp al,0  \n000121ea 74fc je 21E8  \n000121ec bb0700 mov bx,7  \n000121ef b40e mov ah,0Eh  \n000121f1 cd10 int 10h  \n000121f3 ebf2 jmp 21E7  \n000121f5 2bc9 sub cx,cx  \n000121f7 e464 in al,64h  \n000121f9 eb00 jmp 21FB  \n000121fb 2402 and al,2  \n000121fd e0f8 loopne 21F7  \n000121ff 2402 and al,2  \n\n\u003cbr /\u003e\n\n0:001\\\u003e db 12200 120a0+0x1ff  \n00012200 02 c3 49 6e 76 61 6c 69-64 20 70 61 72 74 69 74 ..Invalid partit  \n00012210 69 6f 6e 20 74 61 62 6c-65 00 45 72 72 6f 72 20 ion table.Error   \n00012220 6c 6f 61 64 69 6e 67 20-6f 70 65 72 61 74 69 6e loading operatin  \n00012230 67 20 73 79 73 74 65 6d-00 4d 69 73 73 69 6e 67 g system.Missing  \n00012240 20 6f 70 65 72 61 74 69-6e 67 20 73 79 73 74 65 operating syste  \n00012250 6d 00 00 00 00 62 7a 99-0c 72 0a 94 00 00 80 20 m....bz..r.....   \n00012260 21 00 07 fe ff ff 00 08-00 00 00 f0 ff 04 00 00 !...............  \n00012270 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................  \n00012280 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................  \n00012290 00 00 00 00 00 00 00 00-00 00 00 00 00 00 55 aa ..............U.   \n"
    },
    {
      "id": "125526",
      "timestamp": "2011-03-24T15:11:07+00:00",
      "author": "Sha0",
      "content": "\u003e It falls back to the NT error message (which is also surprising and I missed in the original post) \u0027windows could not start because missing Hal.dll...\u0027  \nThat is typically the case when your BOOT.INI refers to a directory rather than a file. Check for a typo and check that MBR.BIN exists in the very same directory as BOOT.INI and NTLDR.  \n\n\u003e Nopes same error message. But it takes a few seconds for the message to pop up.  \nThat confirms that MBR.BIN is not being invoked.  \n\n\u003e ...it is using BIOS 10h to print, could it be that NTLDR (which already has run before my MBR gets control) changed the graphics mode and hence I am missing the messages?  \nNo.  \n\n\u003e Will do!  \nNice. :smile:  \n\n\u003e But I need to get this to boot first. Shao, my goal is to create something like yu did, NTLDRDD.SYS and the windows driver to boot an image off a VHD.  \nAlmost. Your \"VHD\" and the \"VHDs\" that sara - pmedia seems to use are nothing more than sector-by-sector, flat images. Additionally, your image is not an *HDD* image, it is a *partition* image. VHDs are for HDD images.  \n\nMinor nit-pick: NTBOOTDD.SYS.  \n\n\u003e Is it that the original MBR has a different partition table and this ne one doesnt match? That sounds improbable, as this new MBR should erase all existing memory....\nRight. You should be safe to chain an MBR with a different partition table.   \n"
    },
    {
      "id": "125546",
      "timestamp": "2011-03-24T16:51:16+00:00",
      "author": "amitr0",
      "content": "\\[Sha0\\]\\\u003eThat is typically the case when your BOOT.INI refers to a directory rather than a file. Check \\\u003efor a typo and check that MBR.BIN exists in the very same directory as BOOT.INI and NTLDR.  \n\nNo, no typo here. all files are in the root of C drive. This is xp sp3 32 bit, this should be a noop though!  \n\nCould it be because the failur code sends it to INT18h, which is a \u0027ROM BASIC\u0027 or \u0027PRESS ANY KEY TO REBOOT\u0027 and the VMWARE virtual BIOS doesnt support it, so falls back....again, sounds inplausible though.  \n\n\\[Sha0\\]Almost. Your \"VHD\" and the \"VHDs\" that sara - pmedia seems to use are nothing more than sector-by-sector, flat images. Additionally, your image is not an HDD image, it is a partition image. VHDs are for HDD images.  \n\nThat can be extended, since I will eventually chain to first sector of the partition, in case of a HDD it will be the first sector of the VHDD, and eventually achieve the same thing.  \n\n\u003cbr /\u003e\n\nAny other suggestions would help here.  \n\nA few other questions:  \n\n1. Would it help if I replace the INT18h with a jmp$?  \n2. I want to rewrite the MBR, keeping the INT13h extended functions but removing the TPM related code which is of no interest to me. Which assembler is the best for it? NASM? Are there any special build settings required?  \n3. The actual location of the os file is beyond 8.4 gigs. Hope the LBA code can fetch beyond 1024th cyl?  \n4. Also, which emulator can I use to debug MBR code? That should make things easy to find if my code is getting called.  \n5. Is it possible to change the drive number to boot from? instead of 80h maybe 81h? What I mean is, if I put all of this in a bootable USB, and the image is in a different drive, will that work?  \n\nThanks for your time, and being patient in answering these noob questions?  \n\nThanks  \n\nAmit   \n"
    }
  ]
}